# C和指针
## 基础
### 简介
#### 空白和注释
使用`/*`与`*/`开始与结束注释
> [!TIP] 注释代码
> C程序中，不推荐使用注释符将代码注释掉
> 应使用`#if`指令，如：
> ```C
> #if 0
> 	statements
> #endif
> ```
#### 预处理指令
`#include`：将对应的文件内容替换该指令语句
`#define`：一般使用大写字母，定义字面量常量，将出现定义名称的地方替换为对应的定义值
#### main函数
每个C程序必须有一个main函数，程序执行的起点
>[!NOTE] 函数调用的参数传递
>数组参数是以**引用**的形式传递的（传址调用），标量常量是按**值**传递的

>[!NOTE] NUL/NULL
>NUL是ASCⅡ字符集中”\0“的名字，其字节模式为全0。NULL指一个值为0的指针。
>其均为整型值，且值也相同，可换用
>NULL在stdio.h中定义

#### printf format
常用printf格式代码

| 格式  | 含义      |
| :-: | :------ |
| %d  | 十进制整型值  |
| %o  | 八进制整型值  |
| %x  | 十六进制整型值 |
| %g  | 浮点值     |
| %c  | 一个字符    |
| %s  | 字符串     |
| \n  | 换行      |
#### 字符串常用函数
- printf
- scanf
- puts
- getchar
- putchar
- strncpy
- strcpy
- strchr

# 基本概念
## 环境
1. 翻译环境
2. 执行环境
### 翻译
1. 组成程序的所有源文件->目标代码
2. 目标文件通过*链接器*绑定

编译过程：
1. **预处理器**
2. **解析**
3. **优化器**

编译和链接

```shell
cc program.c # 编译后自动删除目标文件（.o）
cc main.o lookup.o sort.c # 编译C文件并将其和目标文件链接
cc -c program.c # 编译为.o文件
cc -c main.c sort.c # 为每个文件产生一个目标文件
cc main.o sort.o # 链接多个目标文件
```

#### 执行
1. 程序载入内存
2. 初始化（处理命令行参数等），调用main函数
3. 执行代码
	1. 运行时**堆栈**
	2. **静态**内存

### 词法规则
#### 字符
三字母词
#### 注释
会被预处理器替换为空格
#### 程序风格
1. 空格分隔不同的逻辑代码段
2. if等语句、函数原型：括号和表达式之间留出空格
3. 多数操作符的使用中，中间隔以空格
4. 嵌套于其他语句的语句使用Tab进行缩进
5. 大部分注释成块出现
6. 函数等一中，返回类型独立一行，函数名在下一行起始处

## 数据
### 基本数据类型
1. 整型
2. 浮点型
3. 指针
4. 聚合类型
#### 整型
1. 字符
2. 短整型
3. 整型
4. 长整型
均分为**有符号**和**无符号**两种

- 整型字面值
	- 在字面值后面添加`L`/`l`/`u`/`U`来表明其为长/无符号整型
	- 数值以0开头则为八进制，以0x开头则为十六进制
	- 字符常量：类型总为int，不能添加unsigned/long后缀，用单引号包围起来的单个字符
	- 多字节常量前加”L“，则为**宽字符常量**，如`L'x'`
- 枚举类型
	- 其值为符号常量，而非字面值
	- 声明方式：
		```c
		enum Jar_Type { CUP,PINT, QUART, HALF_GALLON, GALLON };
		```
	- 其中变量实际以整型的方式存储，其实际值均为整型值

#### 浮点类型
float、double、long double
#### 指针
- 字符串常量，NUL作为终止符，字符串内部不能有NUL字节，其直接值是一个**指针**

### 基本声明
变量声明的基本形式：
```c
说明符（一个或多个） 声明表达式列表
```
#### 初始化
变量名=变量值
#### 声明简单数组
```c
int values[20]
```
>[!TIP] 下标检查
>若数组下标值是确定正确的，则无需检测；反之，则必须检测其位于有效范围
#### 声明指针
```c
int *a;
```
`int`为标识符，`*a`为表达式，表明表达式产生的结果类型为标识符，故a为指向int类型的指针

### typedef
为数据类型定义新名字
```c
typedef char *ptr_to_ char
```
>[!TIP]`typedef` vs `#define`
>使用typedef而非`#define`来定义新类型名，是因为后者无法正确处理指针类型
### 常量
const，值无法修改
```c
int const * const ptr; //指向常量的常量指针
```
>[!TIP] 创建名字常量
>#define与const均可用于声明名字常量，且只要允许使用字面值常量的地方均可使用前者，故更推荐使用前者

### 作用域
四种作用域
- 文件作用域
- 函数作用域
- 代码块作用域
- 原型作用域
标识符声明的位置决定其作用域
#### 代码块作用域
- 由一对花括号包围
- 嵌套代码块：
	- 内层代码块标识符将隐藏外层同名标识符
#### 文件作用域
所有在代码块之外声明的标识符均具有文件作用域
	#### 原型作用域
适用于在函数原型中声明的参数名
#### 函数作用域
适用于语句标签，用于goto语句
一个函数中的所有语句标签必须唯一

### 链接属性
决定如何处理不同文件中出现的标识符；
标识符作用域与链接属性有关，但两者不同；
分为：
- external
	- 均属统一实体
- internal
	- 在同一个源文件的所有声明中均指同一个实体，而不同源文件中则分属不同实体
- none
	- 视为单独个体，该标识符的多个声明被视为独立不同的实体
使用`extern`和`static`关键字以修改标识符的链接属性
- 某个声明若正常情况下为external链接属性，在其前面使用static关键字可使其变为internal
 > [!TIP] extern使用位置
 > 一般在定义时不添加，而在使用该变量的其他原文的声明中使用

仅在第一次声明时生效，在之后不会改变第一次声明指定的链接属性
### 存储类型
- 存储变量的内存类型
- 决定变量何时创建、销毁以及值的保存时长
- 分为
	- 普通内存
	- 运行时堆栈
	- 硬件寄存器
- 变量的缺省存储类型取决于声明位置
	- 在代码块之外声明的变量存储于静态内存中，即为“静态变量”
		- 无法为其指定其他存储类型
		- 在程序整个执行期间存在
		- 若非重新赋值或程序结束，值保持不变
	- 代码块内部声明的变量缺省存储于堆栈中，为“自动变量”
		- 当程序执行到声明自动变量的代码块时，其被创建，离开时被销毁
		- 重复执行时，每次都重新创建
	- 代码块内部声明的变量，使用static关键字，变为静态变量
		- 作用域不受影响
		- 形参不能声明为静态
	- register用于自动变量的声明，使其存储于硬件寄存器，为“寄存器变量”
		- 访问效率更高，但编译器未必处理该关键字
		- 创建与销毁事件与自动变量相同
 
 ### static关键字
 - 用于函数定义、代码块之外的变量声明：修改标识符的链接属性，存储类型与作用域不受影响
	 - 用于代码块内部的变量声明：修改变量的存储类型  
## 语句
### 空语句
一个分号
### 表达式语句
C语句不存在专门的“赋值语句”，而是通过表达式语句赋值
### 代码块
由一对花括号包围
### if语句
C语言无布尔类型，而使用整型，零值为假，非零值为真
else子句从属于最靠近其的不完整的if语句
### while
### for
### do
### switch
```c
switch( [expression] )
	[statement]
```
一般为:
```c
switch( [expression] ) {
	[statement-list]
}
```
使用case标签贯穿语句列表：
```c
case [constant-expression]
```
每个case标签必须具有一个唯一的值
常量表达式（constant-expression）为在编译期间求值的表达式
其只决定执行入口，将会执行到switch全部语句的结束，除非使用break
#### default子句
用于匹配其他case都不匹配的情况，一个switch语句中只能有一个，可以出现在任何位置
### goto
```c
goto [语句标签];
```
语句标签：标识符+冒号

## 操作符和表达式
### 操作符
#### 算术操作符
`+ - * / %`
#### 移位运算符
左移：填充零
右移：
- 逻辑移位：用0填充
- 算数移位（取决于编译器）
>[!TIP]移位负数
>```c
>a << -5
>```
>结果是未定义的，应避免使用

#### 位运算符
`& | ^`
#### 赋值
>[!TIP]
>```c
>a = x = y + 3;
>```
>a与x未必相等，类型不匹配可能导致截断
>如:
>```c
>char ch;
>while( ( ch = getchar() ) != EOF ) ...
>```
>ch为字符型，EOF为整型
#### 单目操作符
- `!`： 逻辑反
- `~`：补位
- `++`
- `--`
- `+`
- `-`
- `&`
- `*`
- `sizeof`
- `([类型])`

#### 关系操作符
结果为整型值
#### 逻辑操作符
对表达式求值，`&&`和`||`
短路求值
#### 条件操作符
```c
[expression] ? [expression1] : [expression2]
```
#### 逗号操作符
将多个表达式分隔开，自左至右逐个求值，整个逗号表达式的值为最后表达式的值
#### 下标引用、函数调用和结构成员
### 布尔值
C不具备布尔类型，而用整型值代替，规则：
0为假，非0为真
### 左值和右值

### 表达式求值
#### 隐式类型转换
整型算术运算至少以缺省整型类型的精度进行；
整型提升：表达式中的字符性和短整型操作数在使用之前被转换为普通整型
#### 算术转换
寻常算术转换
```c
long double
double
float
unsigned long int
long int
unsigned int
int
```
当各个操作数属于不同类型时，将排名低的操作数转换为排名高的类型
#### 操作符的属性
## 指针
### 值和类型
一个值的类型取决于其使用方式
### 间接访问操作符
间接访问/解引用指针：通过一个指针访问其所指向的地址
### 未初始化和非法的指针
>[!TIP]指针初始化
>应对所有指针变量进行显示初始化，或指定为具体地址，或初始化为NULL
### NULL指针
>[!TIP] 指针解引用
>在对指针进行解引用操作之前，必须确保其非NULL指针
### 指针、间接访问和左值
指针变量可以作为左值，因为其为变量
### 指针常量
### 指针的指针
### 指针表达式
### 指针运算
#### 算术运算
增减的值为指针类型对应的大小
## 函数
### 函数声明
#### 原型
函数原型中加入参数名是不必要的，但是是推荐的
### 函数参数
所有参数都是传值调用
### ADT和黑盒
C可以用于设计和实现抽象数据类型（ADT, abstract data type），因为其可以限制函数和数据定义的作用域，也称为“黑盒”设计
分为接口和实现两部分
通过`static`来限制对模块的访问，其可限制对非接口的函数/数据的访问
### 递归
通过运行时堆栈支持
#### 递归与迭代 
### 可变参数列表
#### stdarg 宏
可变参数列表通过定义于 stdarg.h 头文件中的宏实现，包括
- 类型 va_list
- 宏
	- va_start
	- va_arg
	- va_end
参数列表中的省略号表示未知类型和数量的参数，在函数原型声明中，也需使用该记法

- 使用va_start来初始化va_list类型的变量，第一个参数为va_list类型变量的名字，第二个参数为省略号前最后一个有名字的参数，初始化过程将va_list类型变量的值设置为指向可变参数部分的第一个参数
- 访问参数：使用va_arg，该宏接收两个参数：va_list变量和参数列表中的下一个参数类型，返回该参数值，并使va_list指向下一个可变参数
- 当访问完毕最后一个可变参数后，需调用va_end
## 数组
### 一维数组
数组名的值是指针*常量*
在两种情况下，数组名不用指针常量来表示：
- sizeof
- &
#### 下标引用
除优先级外，下标引用和指针引用完全相同
##### 初始化
- 静态和自动初始化
### 多维数组
多维数组元素存储顺序按照最右侧下标率先变化的原则，即行主序

## 字符串、字符和字节
### 字符串基础
零个或多个字符，并以一个位模式为全0的NUL字节结尾。NUL本身不是字符串的一部分，不计入字符串长度。
### 字符串长度
>[!TIP] strlen
>```c
>size_t strlen( char const *string );
>```
>注意其返回值为`size_t`，为无符号整数类型，故`if( strlen( x ) - strlen( y ) >= 0 )` 永远为真
### 错误信息
当调用函数、请求操作系统执行一些功能时，若出现错误，操作系统通过设置一个外部的整型变量`errno`进行错误代码报告，`strerror`将其中一个错误代码作为参数并返回一个指向用于描述错误的字符串的指针：
```c
char *strerror( int error_number );
```

## 结构和联合
结构式一些值的集合，这些值称为**成员**，每个成员的类型可能不同
成员通过名字访问
### 结构基础知识
#### 结构声明
>[!TIP] 声明
>```c
>struct {
>	int a;
>	char b;
>} x, y;
>```
>其中x与y属于不同类型
>而
>```c
>struct SIMPLE {
>	int a;
>	 char b;
>};
>struct SIMPLE x, y;
>```
>中x与y则为同一类型。
>```c
>typedef struct {
>	int a;
>	 char b;
>} simple;
>simple x, y;
>```

#### 结构成员的直接访问
通过点操作符`.`进行访问
#### 结构成员的间接访问
当拥有的是**指向结构的指针**时，可以使用`->`访问其成员
#### 不完整声明
先只声明结构名，以便在另一个结构定义时可以在成员中包含该结构的指针：
```c
struct B;
struct A {
	struct B *ptr;
};
struct B {
	struct A *prt;
};
```
### 结构、指针和成员
### 位段
位段的声明和普通结构成员的声明相同，除了：
- 必须声明为`int`、`signed int`或`unsigned int`类型
- 位段成员名后跟随一个冒号和一个整数，指定该位段所占的位数
```c
struct CHAR {
	unsigned ch : 7;
	unsigned font: 6;
	unsigned size: 19;
}
```
### 联合
联合的所有成员引用的是内存中的相同位置
## 动态内存分配
### malloc/free
```c
void *malloc( size_t size );
void free( void *pointer );
void *calloc( size_t num_elements, size_t element_size );
void realloc( void *ptr, size_t new_size );
```
### 常见动态内存错误
- 对NULL指针进行解引用
- 对分配的内存进行操作时越过边界
- 释放非动态分配的内存
- 试图释放一块动态内存的一部分
- 使用已被释放的动态内存
## 使用结构和指针
### 单链表
### 双链表
## 高级指针
### 函数指针
#### 回调函数
用户将函数指针作为参数传递给其他函数，后者“回调“用户的函数
### 命令行参数
## 预处理器
- 删除注释
- 插入被#include指令包含的文件的内容
- 定义和替换由#define指令定义的符号
- 确定代码的部分内容是否应根据一些条件编译指令进行编译
### 预定义符号
 - `__FILE__`：进行编译的源文件名
 - `__LINE`：文件当前行的行号
 - `__DATE__`：文件被编译的日期
 - `__TIME__`：文件被编译的时间
 - `__STDC__`：编译器是否遵循ANSI C，若是则为1
 ### `#define`
 #### 宏
 ```c
 #define name([parameter-list]) stuff
 
 #define SQUARE(x) ( (x) * (x) )
 ```
#### 宏的副作用
```c
#define MAX( x, y ) ( (x) > (y) ? (x) : (y) )
z = MAX( x++ , y++ );
```
#### `undef`
移除一个宏定义 
#### 命令行定义
UNIX编译器使用-D选项
```c
-Dname //name的值为1
-Dname=stuff
```
#### 函数库文件包含
```c
#include <[filename]>
```
#### 本地文件包含
```c
#include "[filename]"
```
